# 01 · Introduction and Motivation

Algorithms are the playbook we reach for when raw intuition is not enough. Interviews, production systems, and side projects all reward the engineer who recognizes patterns quickly and turns them into repeatable steps.

## Learning objectives
- Refresh what an algorithm is and how it differs from a finished program
- Understand why interviews lean on algorithmic questions and how that maps to real work
- Clarify the relationship between algorithms, data structures, and programming languages

## Why algorithms matter
> *Programming is the process of taking an algorithm and encoding it into a notation,
> a programming language, so that it can be executed by a computer. Without an algorithm there can be no program.*

Strong algorithmic reasoning lets you:
- Decompose ambiguous problems into smaller, verifiable steps
- Evaluate multiple approaches quickly by reasoning about cost before writing code
- Communicate ideas crisply, a skill that interviewers and teammates depend on

## Algorithms vs. code
An algorithm exists independently from the language you use to express it. It is the recipe. A program is one concrete implementation of that recipe, adapted to a specific kitchen—language, libraries, hardware. When you learn a new algorithm, you gain an interchangeable mental model you can re-use across roles, stacks, and even industries.

## Abstractions in the stack
Low-level languages (e.g. assembly) expose registers and instructions. Mid-level languages (C, C++) build expressive control structures on top of those instructions. High-level languages (Python, JavaScript) add batteries—collection types, built-in algorithms, memory management.

Climbing this ladder hides details, but the details still influence performance. Interview questions aim to reveal whether you can reason beneath the abstractions when it matters: tight loops, memory pressure, data-model trade-offs.

## Interview checkpoints
- Can you restate a problem in your own words before jumping to code?
- Do you identify the input/output shape, constraints, and success criteria?
- Are you comfortable tracing a solution with pen and paper to validate it?
